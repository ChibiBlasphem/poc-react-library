{"version":3,"file":"RangeSlider.stories.37cdb57a.js","sources":["../../src/contexts/DOMContextContext.tsx","../../src/contexts/ScrollContext.tsx","../../src/hooks/useAnchor.ts","../../src/hooks/useClickOutside.ts","../../src/hooks/useHover.ts","../../src/hooks/usePortalContainer.ts","../../src/components/Tooltip/Tooltip.styles.ts","../../src/components/Tooltip/Tooltip.tsx","../../src/components/RangeSlider/RangeSlider.hooks.ts","../../src/components/RangeSlider/RangeSlider.styles.ts","../../src/components/RangeSlider/RangeSlider.tsx"],"sourcesContent":["import type { ReactNode, RefObject } from 'react';\nimport { createContext, useContext, useEffect, useState } from 'react';\n\nconst DOMContextContext = createContext<HTMLElement | null>(null);\n\nexport interface DOMContextProviderProps {\n  children: ReactNode;\n  container: RefObject<HTMLElement>;\n}\n\nexport function DOMContextProvider({ children, container: containerRef }: DOMContextProviderProps) {\n  const [container, setContainer] = useState<HTMLElement | null>(null);\n\n  useEffect(() => {\n    setContainer(containerRef.current);\n  }, [containerRef]);\n\n  return <DOMContextContext.Provider value={container}>{children}</DOMContextContext.Provider>;\n}\n\nexport function useDOMContext(ref: RefObject<Element>) {\n  const context = useContext(DOMContextContext);\n  return context ?? ref.current?.ownerDocument ?? document;\n}\n","import { createContext, ReactNode, RefObject, useContext, useMemo } from 'react';\n\ninterface ScrollContextValue {\n  add: (listener: ScrollListener) => () => void;\n  remove: (listener: ScrollListener) => void;\n}\n\nconst ScrollContext = createContext<ScrollContextValue>({\n  add(listener) {\n    window.addEventListener('scroll', listener);\n    return () => {\n      window.removeEventListener('scroll', listener);\n    };\n  },\n  remove(listener) {\n    window.removeEventListener('scroll', listener);\n  },\n});\n\nexport type ScrollListener = (e: Event) => void;\nexport interface ScrollProviderProps<El extends HTMLElement> {\n  children: ReactNode;\n  targetRef: RefObject<El>;\n}\n\nexport function ScrollProvider<El extends HTMLElement>({\n  children,\n  targetRef,\n}: ScrollProviderProps<El>) {\n  const contextValue = useMemo(() => {\n    return {\n      add: (listener: ScrollListener) => {\n        const target = targetRef.current;\n        if (!target) {\n          return () => {\n            // No event\n          };\n        }\n\n        target.addEventListener('scroll', listener);\n        return () => {\n          target.removeEventListener('scroll', listener);\n        };\n      },\n      remove: (listener: ScrollListener) => {\n        const target = targetRef.current;\n        if (!target) return;\n\n        target.removeEventListener('scroll', listener);\n      },\n    };\n  }, [targetRef]);\n\n  return <ScrollContext.Provider value={contextValue}>{children}</ScrollContext.Provider>;\n}\n\nexport function useScroll() {\n  return useContext(ScrollContext);\n}\n","import { RefObject, useCallback, useLayoutEffect, useRef, useState } from 'react';\n\nimport { useScroll } from '../contexts/ScrollContext';\n\nconst CROPPED_OFFSET = 10;\n\nexport const horizontalOrientations = ['left', 'right'] as const;\nexport const verticalOrientations = ['top', 'bottom'] as const;\n\nexport const isHorizontalOrientation = (\n  orientation: AnchorOrientation\n): orientation is HorizontalOrientation => {\n  return horizontalOrientations.includes(orientation as HorizontalOrientation);\n};\nexport const isVerticalOrientation = (\n  orientation: AnchorOrientation\n): orientation is VerticalOrientation => {\n  return verticalOrientations.includes(orientation as VerticalOrientation);\n};\n\nexport type HorizontalOrientation = typeof horizontalOrientations[number];\nexport type VerticalOrientation = typeof verticalOrientations[number];\nexport type AnchorOrientation = HorizontalOrientation | VerticalOrientation;\n\nexport type Offset = number | ((size: number) => number);\n\nexport type AnchorOffset = {\n  mainAxis?: Offset;\n  crossAxis?: Offset;\n  anchor?: Offset;\n};\n\nexport type SurroundingOffset = {\n  top?: Offset;\n  right?: Offset;\n  bottom?: Offset;\n  left?: Offset;\n};\n\nexport type Position = {\n  top: number;\n  left: number;\n};\nexport type UseAnchorOptions = {\n  orientation?: AnchorOrientation;\n  offset?: AnchorOffset;\n  shouldRelayout?: () => boolean;\n  reflectMainAxisWhenCropped?: boolean;\n  moveCrossAxisWhenCropped?: boolean;\n  surroundingOffset?: SurroundingOffset;\n};\n\nfunction getOffset(size: number, offset: Offset, direction: 1 | -1) {\n  return typeof offset === 'number' ? offset * direction : offset(size) * direction;\n}\n\nfunction getSurroundingOffsets(parentWindow: Window, surroundingOffset: SurroundingOffset) {\n  const top = getOffset(parentWindow.innerHeight, surroundingOffset.top ?? CROPPED_OFFSET, 1);\n  const bottom = getOffset(\n    parentWindow.innerHeight,\n    surroundingOffset.bottom ?? CROPPED_OFFSET,\n    -1\n  );\n  const left = getOffset(parentWindow.innerWidth, surroundingOffset.left ?? CROPPED_OFFSET, 1);\n  const right = getOffset(parentWindow.innerWidth, surroundingOffset.right ?? CROPPED_OFFSET, -1);\n\n  return { top, right, bottom, left };\n}\n\nfunction calculatePosition(\n  anchorRect: DOMRect,\n  selfRect: DOMRect,\n  orientation: AnchorOrientation,\n  { mainAxis = 0, crossAxis = 0, anchor = 0 }: AnchorOffset\n) {\n  switch (orientation) {\n    case 'right':\n      return {\n        top: Math.round(\n          anchorRect.top +\n            getOffset(selfRect.height, crossAxis, -1) +\n            getOffset(anchorRect.height, anchor, 1)\n        ),\n        left: Math.round(\n          anchorRect.left + anchorRect.width + getOffset(selfRect.width, mainAxis, 1)\n        ),\n      };\n    case 'left':\n      return {\n        top: Math.round(\n          anchorRect.top +\n            getOffset(selfRect.height, crossAxis, -1) +\n            getOffset(anchorRect.height, anchor, 1)\n        ),\n        left: Math.round(\n          anchorRect.left - selfRect.width + getOffset(selfRect.width, mainAxis, -1)\n        ),\n      };\n    case 'top':\n      return {\n        top: Math.round(\n          anchorRect.top - selfRect.height + getOffset(selfRect.height, mainAxis, -1)\n        ),\n        left: Math.round(\n          anchorRect.left +\n            getOffset(selfRect.width, crossAxis, -1) +\n            getOffset(anchorRect.width, anchor, 1)\n        ),\n      };\n    case 'bottom':\n      return {\n        top: Math.round(\n          anchorRect.top + anchorRect.height + getOffset(selfRect.height, mainAxis, 1)\n        ),\n        left: Math.round(\n          anchorRect.left +\n            getOffset(selfRect.width, crossAxis, -1) +\n            getOffset(anchorRect.width, anchor, 1)\n        ),\n      };\n  }\n}\n\nexport function useAnchor(\n  anchorRef: RefObject<Element>,\n  selfRef: RefObject<HTMLElement>,\n  options: UseAnchorOptions = {}\n): {\n  anchor: Position;\n  orientation: AnchorOrientation;\n  crossAxisDifference: number;\n} {\n  const {\n    orientation: baseOrientation = 'left',\n    offset = {},\n    surroundingOffset = {},\n    shouldRelayout,\n    reflectMainAxisWhenCropped = false,\n    moveCrossAxisWhenCropped = false,\n  } = options;\n\n  const scrollContext = useScroll();\n  const lastOrientation = useRef(baseOrientation);\n  const [orientation, setOrientation] = useState(baseOrientation);\n  const [crossAxisDifference, setCrossAxisDifference] = useState(0);\n  const [anchor, setAnchor] = useState<Position>({ top: 0, left: 0 });\n  const lastAnchor = useRef<Position>(anchor);\n\n  if (lastOrientation.current !== baseOrientation) {\n    lastOrientation.current = baseOrientation;\n    setOrientation(baseOrientation);\n  }\n\n  const mainAxisOffset = offset.mainAxis;\n  const crossAxisOffset = offset.crossAxis;\n  const anchorOffset = offset.anchor;\n\n  const reposition = useCallback(() => {\n    const userOffset = {\n      mainAxis: mainAxisOffset,\n      crossAxis: crossAxisOffset,\n      anchor: anchorOffset,\n    };\n    if (!anchorRef.current || !selfRef.current || (shouldRelayout && !shouldRelayout())) return;\n\n    const parentWindow = anchorRef.current.ownerDocument?.defaultView;\n    if (!parentWindow) return;\n\n    const anchorRect = anchorRef.current.getBoundingClientRect();\n    const selfRect = selfRef.current.getBoundingClientRect();\n\n    let { top, left } = calculatePosition(anchorRect, selfRect, baseOrientation, userOffset);\n    const parentOffsets = getSurroundingOffsets(parentWindow, surroundingOffset);\n\n    const isCroppedVertically =\n      top + selfRect.height > parentWindow.innerHeight + parentOffsets.bottom ||\n      top < parentOffsets.top;\n    const isCroppedHorizontally =\n      left + selfRect.width > parentWindow.innerWidth + parentOffsets.right ||\n      left < parentOffsets.left;\n\n    if (reflectMainAxisWhenCropped) {\n      let tmpOrientation = baseOrientation;\n\n      if (isHorizontalOrientation(baseOrientation) && isCroppedHorizontally) {\n        const newOrientation: AnchorOrientation = baseOrientation === 'left' ? 'right' : 'left';\n        const { top: recalculedTop, left: recalculedLeft } = calculatePosition(\n          anchorRect,\n          selfRect,\n          newOrientation,\n          userOffset\n        );\n\n        if (\n          recalculedLeft + selfRect.width <= parentWindow.innerWidth + parentOffsets.right &&\n          recalculedLeft >= parentOffsets.left\n        ) {\n          tmpOrientation = newOrientation;\n          top = recalculedTop;\n          left = recalculedLeft;\n        }\n      }\n      if (isVerticalOrientation(baseOrientation) && isCroppedVertically) {\n        const newOrientation: AnchorOrientation = baseOrientation === 'top' ? 'bottom' : 'top';\n        const { top: recalculedTop, left: recalculedLeft } = calculatePosition(\n          anchorRect,\n          selfRect,\n          newOrientation,\n          userOffset\n        );\n\n        if (\n          recalculedTop + selfRect.height <= parentWindow.innerHeight + parentOffsets.bottom &&\n          recalculedTop >= parentOffsets.top\n        ) {\n          tmpOrientation = newOrientation;\n          top = recalculedTop;\n          left = recalculedLeft;\n        }\n      }\n\n      setOrientation(tmpOrientation);\n    }\n\n    if (moveCrossAxisWhenCropped) {\n      let tmpCrossAxisDifference = 0;\n      if (isHorizontalOrientation(baseOrientation) && isCroppedVertically) {\n        let recalculatedTop;\n        if (top < parentOffsets.top) {\n          recalculatedTop = Math.min(parentOffsets.top, anchorRect.top);\n        } else if (top + selfRect.height > parentWindow.innerHeight + parentOffsets.bottom) {\n          recalculatedTop = Math.max(\n            parentWindow.innerHeight + parentOffsets.bottom - selfRect.height,\n            anchorRect.top + anchorRect.height - selfRect.height\n          );\n        }\n        if (recalculatedTop) {\n          tmpCrossAxisDifference = recalculatedTop - top;\n          top = recalculatedTop;\n        }\n      }\n      if (isVerticalOrientation(baseOrientation) && isCroppedHorizontally) {\n        let recalculatedLeft;\n        if (left < parentOffsets.left) {\n          recalculatedLeft = Math.min(parentOffsets.left, anchorRect.left);\n        } else if (left + selfRect.width > parentWindow.innerWidth + parentOffsets.right) {\n          recalculatedLeft = Math.max(\n            parentWindow.innerWidth + parentOffsets.right - selfRect.width,\n            anchorRect.left + anchorRect.width - selfRect.width\n          );\n        }\n        if (recalculatedLeft) {\n          tmpCrossAxisDifference = recalculatedLeft - left;\n          left = recalculatedLeft;\n        }\n      }\n      setCrossAxisDifference(tmpCrossAxisDifference);\n    }\n\n    if (lastAnchor.current.top === top && lastAnchor.current.left === left) {\n      return;\n    }\n\n    lastAnchor.current = { top, left };\n    setAnchor({ top, left });\n  }, [\n    surroundingOffset,\n    mainAxisOffset,\n    crossAxisOffset,\n    anchorOffset,\n    baseOrientation,\n    reflectMainAxisWhenCropped,\n    moveCrossAxisWhenCropped,\n    anchorRef,\n    selfRef,\n    shouldRelayout,\n  ]);\n\n  useLayoutEffect(() => {\n    if (!anchorRef.current) return;\n    if (shouldRelayout && !shouldRelayout()) return;\n\n    const parentWindow = anchorRef.current.ownerDocument;\n    if (!parentWindow) return;\n\n    const removeScrollEvent = scrollContext.add(reposition);\n    parentWindow.addEventListener('resize', reposition);\n\n    reposition();\n\n    return () => {\n      removeScrollEvent();\n      parentWindow.removeEventListener('resize', reposition);\n    };\n  }, [\n    reposition,\n    baseOrientation,\n    reflectMainAxisWhenCropped,\n    moveCrossAxisWhenCropped,\n    anchorRef,\n    selfRef,\n    shouldRelayout,\n    scrollContext,\n  ]);\n\n  return {\n    anchor,\n    orientation,\n    crossAxisDifference,\n  };\n}\n","import { RefObject, useEffect } from 'react';\n\nexport function useClickOutside(\n  domContext: Element | Document,\n  refs: RefObject<Element>[],\n  onClickOutside?: () => void\n) {\n  useEffect(() => {\n    if (refs.length < 1) {\n      throw 'There should be at least one ref';\n    }\n\n    const elements = refs.reduce((els, ref) => {\n      return ref.current ? [...els, ref.current] : els;\n    }, [] as Element[]);\n\n    const handler = (e: Event) => {\n      if (\n        onClickOutside &&\n        elements.every((element) => element !== e.target && !element.contains(e.target as Node))\n      ) {\n        onClickOutside();\n      }\n    };\n\n    domContext.addEventListener('click', handler);\n    domContext.addEventListener('touchend', handler);\n    return () => {\n      domContext.removeEventListener('click', handler);\n      domContext.removeEventListener('touchend', handler);\n    };\n  }, [domContext, refs, onClickOutside]);\n}\n","import { useRef, useState } from 'react';\n\ntype UseHoverReturn = [boolean, { onMouseOver: () => void; onMouseLeave: () => void }];\n\nexport interface UseHoverOptions {\n  delayEnter?: number;\n  delayLeave?: number;\n}\n\nexport const DEFAULT_HOVER_ENTER_DELAY = 150;\nexport const DEFAULT_HOVER_LEAVE_DELAY = 150;\n\nexport function useHover({\n  delayEnter = DEFAULT_HOVER_ENTER_DELAY,\n  delayLeave = DEFAULT_HOVER_LEAVE_DELAY,\n}: UseHoverOptions = {}): UseHoverReturn {\n  const toLeaveRef = useRef<ReturnType<typeof setTimeout>>();\n  const toOverRef = useRef<ReturnType<typeof setTimeout>>();\n  const [isHover, setIsHover] = useState(false);\n\n  const onMouseOver = () => {\n    if (isHover) {\n      if (toLeaveRef.current) {\n        clearTimeout(toLeaveRef.current);\n        toLeaveRef.current = undefined;\n      }\n    } else {\n      toOverRef.current = setTimeout(() => {\n        if (toOverRef.current !== undefined) {\n          setIsHover(true);\n        }\n      }, delayEnter);\n    }\n  };\n\n  const onMouseLeave = () => {\n    if (!isHover) {\n      if (toOverRef.current) {\n        clearTimeout(toOverRef.current);\n        toOverRef.current = undefined;\n      }\n    } else {\n      toLeaveRef.current = setTimeout(() => {\n        if (toLeaveRef.current !== undefined) {\n          setIsHover(false);\n        }\n      }, delayLeave);\n    }\n  };\n\n  return [isHover, { onMouseOver, onMouseLeave }];\n}\n","import { RefObject, useEffect } from 'react';\n\nexport function usePortalContainer(\n  generatedId: string,\n  parentContainer: HTMLElement | Document | undefined,\n  container: RefObject<HTMLElement> | undefined,\n  setContainer: (container: HTMLElement) => void\n) {\n  useEffect(() => {\n    if (!parentContainer) return;\n\n    const parentElement = 'body' in parentContainer ? parentContainer.body : parentContainer;\n\n    let tmpContainer = container\n      ? container.current\n      : (parentElement.querySelector(`#${generatedId}`) as HTMLElement);\n    if (!tmpContainer) {\n      tmpContainer = document.createElement('div');\n      tmpContainer.id = generatedId;\n      parentElement.appendChild(tmpContainer);\n    }\n\n    setContainer(tmpContainer);\n  }, [generatedId, setContainer, parentContainer, container]);\n}\n","import type { FlattenSimpleInterpolation } from 'styled-components';\nimport styled, { css } from 'styled-components';\n\nimport type { AnchorOrientation } from '../../hooks/useAnchor';\n\ntype TooltipArrowProps = {\n  orientation: AnchorOrientation;\n  movedBy: number;\n};\n\nconst setArrowPosition = (orientation: AnchorOrientation): FlattenSimpleInterpolation => {\n  switch (orientation) {\n    case 'bottom':\n      return css`\n        top: 100%;\n        left: 50%;\n        transform: translateX(-50%);\n        width: 20px;\n        height: 10px;\n\n        &:after {\n          top: 0;\n          left: 50%;\n        }\n      `;\n    case 'top':\n      return css`\n        top: -10px;\n        left: 50%;\n        transform: translateX(-50%);\n        width: 20px;\n        height: 10px;\n\n        &:after {\n          top: 10px;\n          left: 50%;\n        }\n      `;\n    case 'right':\n      return css`\n        top: 50%;\n        left: 100%;\n        transform: translateY(-50%);\n        width: 10px;\n        height: 20px;\n\n        &:after {\n          top: 10px;\n          left: 0%;\n        }\n      `;\n    case 'left':\n      return css`\n        top: 50%;\n        left: -10px;\n        transform: translateY(-50%);\n        width: 10px;\n        height: 20px;\n\n        &:after {\n          top: 10px;\n          left: 10px;\n        }\n      `;\n  }\n};\n\nexport const Arrow = styled.div.attrs<TooltipArrowProps>(({ orientation, movedBy }) => {\n  return orientation === 'left' || orientation === 'right'\n    ? { style: { marginTop: `${-movedBy}px` } }\n    : { style: { marginLeft: `${-movedBy}px` } };\n})<TooltipArrowProps>`\n  position: absolute;\n  overflow: hidden;\n\n  &:after {\n    content: '';\n    position: absolute;\n    width: 10px;\n    height: 10px;\n    transform: translateX(-50%) translateY(-50%) rotate(45deg);\n    background-color: var(--component-Tooltip-background);\n    box-shadow: 0 0 12px 0 rgba(38, 38, 38, 0.2);\n  }\n\n  ${({ orientation: position }) => setArrowPosition(position)}\n`;\n\nexport const TooltipContainer = styled.div`\n  position: fixed;\n  z-index: 1;\n  background-color: var(--component-Tooltip-background);\n  color: var(--component-Tooltip-text);\n  border-radius: 4px;\n  box-shadow: 0 2px 8px 0 rgba(0, 0, 0, 0.16);\n`;\n\nexport const TooltipWrapper = styled.div`\n  padding: 10px;\n  font-size: 12px;\n`;\n","import type { CSSProperties, MouseEvent, ReactElement, ReactNode, RefObject } from 'react';\nimport { cloneElement, useRef, useState } from 'react';\nimport { createPortal } from 'react-dom';\n\nimport { useDOMContext } from '../../contexts/DOMContextContext';\nimport { AnchorOrientation, useAnchor, UseAnchorOptions } from '../../hooks/useAnchor';\nimport { useClickOutside } from '../../hooks/useClickOutside';\nimport { useHover, UseHoverOptions } from '../../hooks/useHover';\nimport { usePortalContainer } from '../../hooks/usePortalContainer';\n\nimport { Arrow, TooltipContainer, TooltipWrapper } from './Tooltip.styles';\n\nexport const TOOLTIP_CONTAINER_ID = 'react-tooltip-container';\n\ninterface ObjectWithRef<T = unknown> {\n  ref: RefObject<T>;\n}\n\nexport type TooltipProps = {\n  container?: RefObject<HTMLElement>;\n  children?: ReactNode;\n  orientation?: AnchorOrientation;\n  anchorRef: RefObject<Element>;\n  className?: string;\n  onClick?: (event: MouseEvent<HTMLDivElement>) => void;\n  onClickOutside?: () => void;\n  style?: Pick<CSSProperties, 'width' | 'height'> & {\n    '--component-Tooltip-background'?: string;\n    '--component-Tooltip-text'?: string;\n  };\n  onMouseOver?: () => void;\n  onMouseLeave?: () => void;\n  offset?: number;\n  surroundingOffset?: UseAnchorOptions['surroundingOffset'];\n};\n\nconst getArrowPosition = (orientation: AnchorOrientation): AnchorOrientation => {\n  switch (orientation) {\n    case 'left':\n      return 'right';\n    case 'right':\n      return 'left';\n    case 'top':\n      return 'bottom';\n    case 'bottom':\n      return 'top';\n  }\n};\n\nexport function Tooltip({\n  container,\n  children,\n  className,\n  style = {},\n  anchorRef,\n  orientation = 'left',\n  offset = 10,\n  surroundingOffset,\n  onClick,\n  onClickOutside,\n  onMouseLeave,\n  onMouseOver,\n}: TooltipProps) {\n  const tooltipRef = useRef(null);\n  const tooltipDOMContext = useDOMContext(tooltipRef);\n  const [tooltipContainer, setTooltipContainer] = useState<HTMLElement>();\n  const { width, height, ...styleRest } = style;\n  const parentContainer = tooltipDOMContext ?? anchorRef.current?.ownerDocument;\n\n  const {\n    anchor: { top, left },\n    orientation: calculatedOrientation,\n    crossAxisDifference,\n  } = useAnchor(anchorRef, tooltipRef, {\n    orientation,\n    offset: {\n      anchor: (anchorSize) => anchorSize * 0.5,\n      crossAxis: (tooltipSize) => tooltipSize * 0.5,\n      mainAxis: offset,\n    },\n    surroundingOffset,\n    reflectMainAxisWhenCropped: true,\n    moveCrossAxisWhenCropped: true,\n  });\n  useClickOutside(tooltipDOMContext, [anchorRef, tooltipRef], onClickOutside);\n  usePortalContainer(TOOLTIP_CONTAINER_ID, parentContainer, container, setTooltipContainer);\n\n  return tooltipContainer\n    ? createPortal(\n        <TooltipContainer\n          onClick={onClick}\n          onMouseOver={onMouseOver}\n          onMouseLeave={onMouseLeave}\n          ref={tooltipRef}\n          style={{ top: `${top}px`, left: `${left}px`, width, height, ...styleRest }}\n        >\n          <TooltipWrapper className={className}>{children}</TooltipWrapper>\n          <Arrow\n            orientation={getArrowPosition(calculatedOrientation)}\n            movedBy={crossAxisDifference}\n          />\n        </TooltipContainer>,\n        tooltipContainer\n      )\n    : null;\n}\n\nexport type HoverTooltipProps = {\n  children: ReactElement;\n  tooltipContent: TooltipProps['children'];\n  forceWhen?: boolean;\n  disabled?: boolean;\n} & UseHoverOptions &\n  Omit<TooltipProps, 'children' | 'anchorRef' | 'onClickOutside'>;\n\nexport function HoverTooltip({\n  children,\n  forceWhen,\n  disabled,\n  tooltipContent,\n  ...tooltipProps\n}: HoverTooltipProps) {\n  // Trying to get the children ref this way to not force developer to use forwardRef\n  const childrenRef = (children as unknown as ObjectWithRef).ref as RefObject<Element>;\n  const innerRef = useRef<Element>(null);\n  const usedRef = childrenRef || innerRef;\n  const [isHover, hoverEvents] = useHover();\n  const clonedChildren = cloneElement(children, {\n    ref: usedRef,\n    ...hoverEvents,\n  });\n\n  return (\n    <>\n      {clonedChildren}\n      {!disabled && (forceWhen || isHover) && (\n        <Tooltip {...tooltipProps} {...hoverEvents} anchorRef={usedRef}>\n          {tooltipContent}\n        </Tooltip>\n      )}\n    </>\n  );\n}\n","import { MouseEvent as ReactMouseEvent, RefObject, useEffect, useRef, useState } from 'react';\n\nexport interface UseDotMoveOptions {\n  onStartMoving: (position: number) => void;\n  onUpdatePosition: (position: number) => void;\n  onStopMoving: () => void;\n}\n\nexport function useDotMove(\n  railRef: RefObject<HTMLDivElement>,\n  interval: number,\n  positions: number[],\n  { onStartMoving, onStopMoving, onUpdatePosition }: UseDotMoveOptions\n) {\n  const [dotMoving, setDotMoving] = useState<number | null>(null);\n  const lastPositionRef = useRef<number | null>(null);\n\n  const onMouseDown = (e: ReactMouseEvent<HTMLDivElement>, dotNumber: number) => {\n    const rail = railRef.current;\n    if (!rail) return;\n\n    const railRect = rail.getBoundingClientRect();\n    const domRect = e.currentTarget.getBoundingClientRect();\n\n    lastPositionRef.current = domRect.left + domRect.width / 2 - railRect.left;\n    onStartMoving(lastPositionRef.current);\n    setDotMoving(dotNumber);\n  };\n\n  useEffect(() => {\n    if (dotMoving === null) return;\n    if (!railRef.current) return;\n\n    const railRect = railRef.current.getBoundingClientRect();\n\n    const onMouseMove = (e: MouseEvent) => {\n      if (dotMoving === null || lastPositionRef.current === null) {\n        return;\n      }\n\n      const prevPosition = positions[dotMoving - 1];\n      const nextPosition = positions[dotMoving + 1];\n\n      const minPosition = prevPosition !== undefined ? prevPosition + interval : 0;\n      const maxPosition = nextPosition !== undefined ? nextPosition - interval : railRect.width;\n\n      const newPosition = lastPositionRef.current + e.movementX;\n      lastPositionRef.current = newPosition;\n      onUpdatePosition(Math.max(minPosition, Math.min(maxPosition, newPosition)));\n    };\n\n    const onMouseUp = () => {\n      if (dotMoving === null) {\n        return;\n      }\n\n      onStopMoving();\n      setDotMoving(null);\n    };\n\n    document.addEventListener('mousemove', onMouseMove);\n    document.addEventListener('mouseup', onMouseUp);\n\n    return () => {\n      document.removeEventListener('mousemove', onMouseMove);\n      document.removeEventListener('mouseup', onMouseUp);\n    };\n  }, [dotMoving, positions, onUpdatePosition, onStopMoving]);\n\n  return {\n    onMouseDown,\n    dotMoving,\n  };\n}\n","import styled, { css } from 'styled-components';\n\nexport interface RangeSliderDotProps {\n  isMoving: boolean;\n}\n\nexport const RangeSliderDotRoot = styled.div<RangeSliderDotProps>`\n  position: absolute;\n  z-index: 2;\n  height: var(--component-RangeSlider-dot-size);\n  width: var(--component-RangeSlider-dot-size);\n  transform: translate(-50%, -50%);\n  top: 50%;\n  border-radius: 50%;\n  box-sizing: border-box;\n  background-color: var(--component-RangeSlider-dot-color);\n  border: var(--component-RangeSlider-dot-border-size) solid\n    var(--component-RangeSlider-dot-border-color);\n  box-shadow: var(--component-RangeSlider-dot-shadow);\n  cursor: pointer;\n\n  ${(props) =>\n    props.isMoving\n      ? css`\n          background-color: var(--component-RangeSlider-dot-color__moving);\n          border-color: var(--component-RangeSlider-dot-border-color__moving);\n          box-shadow: var(--component-RangeSlider-dot-shadow__moving);\n        `\n      : css`\n          transition: left 0.5s ease 0s;\n          &:hover {\n            background-color: var(--component-RangeSlider-dot-color__hover);\n            border-color: var(--component-RangeSlider-dot-border-color__hover);\n            box-shadow: var(--component-RangeSlider-dot-shadow__hover);\n          }\n        `}\n`;\n\nexport const RangeSliderMark = styled.div`\n  position: absolute;\n  top: 0;\n  transform: translateX(-50%);\n`;\n\nexport const RangeSliderMarks = styled.div`\n  position: absolute;\n  left: 0;\n  top: 100%;\n  width: 100%;\n`;\n\nexport interface RangeSliderProcessProps {\n  isMoving: boolean;\n}\n\nexport const RangeSliderProcess = styled.div<RangeSliderProcessProps>`\n  position: absolute;\n  z-index: 1;\n  height: 100%;\n  top: 0;\n  background-color: var(--component-Rangeslider-process-color);\n  border-radius: calc(var(--component-Rangeslider-height) / 2);\n\n  ${(props) =>\n    !props.isMoving &&\n    css`\n      transition: 0.5s ease 0s;\n      transition-property: left, width;\n    `}\n`;\n\nexport const RangeSliderRail = styled.div`\n  position: relative;\n  width: 100%;\n  height: 100%;\n  transition-property: width, height, left, right, top, bottom;\n  background-color: var(--component-RangeSlider-rail-color);\n  border-radius: calc(var(--component-RangeSlider-height) / 2);\n`;\n\nexport const RangeSliderRoot = styled.div`\n  --component-RangeSlider-height: 4px;\n  --component-RangeSlider-dot-size: 16px;\n  --component-RangeSlider-dot-border-size: 2px;\n  --component-RangeSlider-dot-color: #fff;\n  --component-RangeSlider-dot-color__hover: #fff;\n  --component-RangeSlider-dot-color__moving: #fff;\n  --component-RangeSlider-dot-border-color: transparent;\n  --component-RangeSlider-dot-border-color__hover: transparent;\n  --component-RangeSlider-dot-border-color__moving: transparent;\n  --component-RangeSlider-dot-shadow: 0.5px 0.5px 2px 1px rgb(0 0 0 / 32%);\n  --component-RangeSlider-dot-shadow__hover: 0.5px 0.5px 2px 1px rgb(0 0 0 / 32%);\n  --component-RangeSlider-dot-shadow__moving: 0.5px 0.5px 2px 1px rgb(0 0 0 / 32%);\n  --component-RangeSlider-rail-color: #ccc;\n  --component-Rangeslider-process-color: #3498db;\n\n  position: relative;\n  box-sizing: content-box;\n  user-select: none;\n  display: block;\n  height: var(--component-RangeSlider-height);\n  padding: calc(var(--component-RangeSlider-dot-size) / 2) 0;\n  border-radius: calc(var(--component-Rangeslider-height) / 2);\n`;\n","import { MouseEvent, useEffect, useRef, useState } from 'react';\n\nimport { Tooltip } from '../../components/Tooltip/Tooltip';\nimport { DOMContextProvider } from '../../contexts/DOMContextContext';\n\nimport { useDotMove } from './RangeSlider.hooks';\nimport {\n  RangeSliderDotRoot,\n  RangeSliderMark,\n  RangeSliderMarks,\n  RangeSliderProcess,\n  RangeSliderRail,\n  RangeSliderRoot,\n} from './RangeSlider.styles';\n\nfunction getProcessLimits(\n  railSize: number,\n  positions: number[]\n): null | [start: string, end: string] {\n  if (positions.length < 2 || railSize === 0) return null;\n\n  const start = Math.min(...positions);\n  const end = Math.max(...positions);\n\n  return [`${start}px`, `${end - start}px`];\n}\n\nfunction getNearestInterval(intervalSize: number, position: number) {\n  return Math.round(position / intervalSize);\n}\n\ninterface RangeSliderDotProps {\n  position: number;\n  isMoving: boolean;\n  value: number;\n  onMouseDown: (e: MouseEvent<HTMLDivElement>) => void;\n}\n\nfunction RangeSliderDot({ onMouseDown, position, isMoving, value }: RangeSliderDotProps) {\n  const dotRef = useRef<HTMLDivElement>(null);\n\n  return (\n    <>\n      <RangeSliderDotRoot\n        ref={dotRef}\n        onMouseDown={onMouseDown}\n        style={{ left: `${position}px` }}\n        isMoving={isMoving}\n      />\n      {isMoving && (\n        <Tooltip anchorRef={dotRef} orientation=\"top\">\n          {value}\n        </Tooltip>\n      )}\n    </>\n  );\n}\n\nexport interface RangeSliderProps {\n  values: number[];\n  min: number;\n  max: number;\n  interval?: number;\n  className?: string;\n  marks?: boolean;\n  onChange: (values: number[]) => void;\n}\n\nfunction generateMarks(min: number, max: number, interval: number) {\n  const intervalCount = (max - min) / interval + 1;\n  return Array.from({ length: intervalCount }, (_, i) => min + interval * i);\n}\n\nexport function RangeSlider({\n  values,\n  min,\n  max,\n  className,\n  interval = 1,\n  marks = false,\n  onChange,\n}: RangeSliderProps) {\n  const rootRef = useRef<HTMLDivElement>(null);\n  const sliderRailRef = useRef<HTMLDivElement>(null);\n  const [overridePosition, setOverridePosition] = useState<number>(0);\n  const [railSize, setRailSize] = useState<number>(0);\n  const intervalCount = (max - min) / interval;\n  const intervalPixel = (railSize * interval) / (max - min);\n\n  if (intervalCount !== Math.floor(intervalCount)) {\n    throw new Error('Cannot render RangeSlider. `(max - min)` should be dividable by `interval`');\n  }\n\n  const basePositions = values.map((v) => ((v - min) / interval) * intervalPixel);\n  const { onMouseDown, dotMoving } = useDotMove(sliderRailRef, intervalPixel, basePositions, {\n    onStartMoving(position) {\n      setOverridePosition(position);\n    },\n    onUpdatePosition(position) {\n      setOverridePosition(position);\n    },\n    onStopMoving() {},\n  });\n  const positions = basePositions.map((p, i) => (dotMoving === i ? overridePosition : p));\n  const process = getProcessLimits(railSize, positions);\n  const showMarks = marks && intervalPixel > 40;\n\n  useEffect(() => {\n    if (dotMoving === null) return;\n\n    const newValue = getNearestInterval(intervalPixel, overridePosition) * interval + min;\n    onChange(values.map((v, i) => (i === dotMoving ? newValue : v)));\n  }, [dotMoving, overridePosition, interval, min]);\n\n  useEffect(() => {\n    const rail = sliderRailRef.current;\n    if (!rail) return;\n\n    setRailSize(rail.getBoundingClientRect().width);\n\n    const handleResize = () => {\n      setRailSize(rail.getBoundingClientRect().width);\n    };\n\n    window.addEventListener('resize', handleResize);\n    return () => {\n      window.removeEventListener('resize', handleResize);\n    };\n  }, []);\n\n  return (\n    <RangeSliderRoot ref={rootRef} className={className}>\n      <DOMContextProvider container={rootRef}>\n        {showMarks && (\n          <RangeSliderMarks>\n            {generateMarks(min, max, interval).map((v, i) => (\n              <RangeSliderMark key={i} style={{ left: `${i * intervalPixel}px` }}>\n                {v}\n              </RangeSliderMark>\n            ))}\n          </RangeSliderMarks>\n        )}\n        <RangeSliderRail ref={sliderRailRef}>\n          {process && (\n            <RangeSliderProcess\n              isMoving={dotMoving !== null}\n              style={{ left: process[0], width: process[1] }}\n            />\n          )}\n          {!!railSize &&\n            positions.map((p, i) => {\n              const isMoving = dotMoving === i;\n              return (\n                <RangeSliderDot\n                  key={i}\n                  isMoving={isMoving}\n                  position={isMoving ? overridePosition : p}\n                  onMouseDown={(e) => onMouseDown(e, i)}\n                  value={values[i]!}\n                />\n              );\n            })}\n        </RangeSliderRail>\n      </DOMContextProvider>\n    </RangeSliderRoot>\n  );\n}\n"],"names":["createContext","children","containerRef","useState","useEffect","setContainer","_jsx","container","useContext","window","targetRef","useMemo","target","contextValue","useRef","useCallback","useLayoutEffect","css","orientation","className","anchorRef","surroundingOffset","onClick","onClickOutside","onMouseLeave","onMouseOver","styleRest","width","height","top","left","calculatedOrientation","crossAxisDifference","offset","useClickOutside","usePortalContainer","createPortal","_jsxs","tooltipRef","tooltipProps","forceWhen","disabled","tooltipContent","cloneElement","usedRef","hoverEvents","_Fragment","onMouseDown","position","isMoving","value","dotRef","intervalCount","values","min","max","onChange","dotMoving","setOverridePosition","setRailSize","rootRef","intervalPixel","v","sliderRailRef","p","i"],"mappings":"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"}